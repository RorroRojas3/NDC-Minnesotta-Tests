"use strict";(self.webpackChunktesting_workshop=self.webpackChunktesting_workshop||[]).push([[8522],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),h=u(n),d=a,m=h["".concat(l,".").concat(d)]||h[d]||c[d]||s;return n?r.createElement(m,i(i({ref:t},p),{},{components:n})):r.createElement(m,i({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var u=2;u<s;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9110:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const s={description:"Using third-party APIs in our system can be a problem"},i="Dealing with third-party APIs",o={unversionedId:"integration-testing/api/dealing-with-apis",id:"integration-testing/api/dealing-with-apis",title:"Dealing with third-party APIs",description:"Using third-party APIs in our system can be a problem",source:"@site/docs/integration-testing/api/dealing-with-apis.md",sourceDirName:"integration-testing/api",slug:"/integration-testing/api/dealing-with-apis",permalink:"/integration-testing/api/dealing-with-apis",draft:!1,tags:[],version:"current",frontMatter:{description:"Using third-party APIs in our system can be a problem"},sidebar:"docs",previous:{title:"Creating databases on demand",permalink:"/integration-testing/api/databases-on-demand"},next:{title:"Realistic fake data",permalink:"/integration-testing/api/realistic-fake-data"}},l={},u=[{value:"The problem with APIs",id:"the-problem-with-apis",level:2},{value:"Introducing WireMock.NET",id:"introducing-wiremocknet",level:2},{value:"Let&#39;s build a fake API",id:"lets-build-a-fake-api",level:3},{value:"Creating the fake <code>GitHubApiServer</code>",id:"creating-the-fake-githubapiserver",level:3},{value:"Replacing the real server with the fake one",id:"replacing-the-real-server-with-the-fake-one",level:3},{value:"Exercise: Write two integration tests",id:"exercise-write-two-integration-tests",level:3},{value:"Solutions",id:"solutions",level:4},{value:"Quick refactoring",id:"quick-refactoring",level:3}],p={toc:u};function c(e){let{components:t,...s}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,s,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"dealing-with-third-party-apis"},"Dealing with third-party APIs"),(0,a.kt)("h2",{id:"the-problem-with-apis"},"The problem with APIs"),(0,a.kt)("p",null,"It is very common for services to use either internal or external third-party APIs as part of their functionality.\nFor example, in our case, we are using the ",(0,a.kt)("a",{parentName:"p",href:"https://docs.github.com/en/rest"},"GitHub API")," to validate that the GitHub username provided in ",(0,a.kt)("inlineCode",{parentName:"p"},"Create")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Update")," is valid."),(0,a.kt)("p",null,"The problem with that is that third-part APIs might be unavailable for one reason or another or they might have a credit based system where they can only be called X amount of times per hour.\nIf we have a large test suite, we could exhaust all our credits running our tests. We don't want that."),(0,a.kt)("p",null,"For integration testing it is enough to run our tests and have our system call an API that responds exactly like the original API, without it being that API.\nSo what we need is to run something that accepts requests just like the GitHub API and responds just like the GitHub API."),(0,a.kt)("p",null,"To do that we will use a package called ",(0,a.kt)("strong",{parentName:"p"},"WireMock.NET"),"."),(0,a.kt)("h2",{id:"introducing-wiremocknet"},"Introducing WireMock.NET"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/WireMock-Net/WireMock.Net"},"WireMock.NET")," is a library that allows us to create in-memory versions of the APIs our application would normally call.\nThese APIs can be configured to respond in specific ways when a request that matches a specific URL, path, header, cookie or body content."),(0,a.kt)("p",null,"Our goal here is to replace the GitHub API dependency during our integration test execution with an in-memory version the API that runs as part of our test suite and is used by our integration tests to respond in a way we want it to."),(0,a.kt)("h3",{id:"lets-build-a-fake-api"},"Let's build a fake API"),(0,a.kt)("p",null,"Time for us to use WireMock.NET to build a fake API. This is more of an introduction to WireMock and how it works rather than the exact code we will be using for integration testing."),(0,a.kt)("p",null,"First let's create a simple empty console application.\nYou can either use your IDE's project creation functionality or the ",(0,a.kt)("inlineCode",{parentName:"p"},"dotnet new command")," in the ",(0,a.kt)("inlineCode",{parentName:"p"},"src")," folder:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-commandline"},"dotnet new console -o GitHub.Api.Fake\n")),(0,a.kt)("p",null,"Let's clear the ",(0,a.kt)("inlineCode",{parentName:"p"},"Program.cs"),"'s contents and start by creating the WireMock server object."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"var wiremockServer = WireMockServer.Start();\n")),(0,a.kt)("p",null,"This is all you need to create an start the fake API. Now let's get the randomly assigned port and wait for a key to be pressed before the server is disposed."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Program.s"',title:'"Program.s"'},'var wiremockServer = WireMockServer.Start();\n\nConsole.WriteLine($"WireMock.NET is now running on: {wiremockServer.Url}");\n\nConsole.ReadKey();\nwiremockServer.Dispose();\n')),(0,a.kt)("p",null,"And that's it! Running this app creates an API which you can call.\nHowever at this point no endpoints are configured so calling it will return a ",(0,a.kt)("inlineCode",{parentName:"p"},"404 NotFound")," with the following response body:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "Status": "No matching mapping found"\n}\n')),(0,a.kt)("p",null,"Since what we're trying to do is create a fake GitHub API that returns a GitHub user when their username is provided, let's configure this server to do the same."),(0,a.kt)("p",null,"My GitHub username is Elfocrash and you can get my GitHub user details by calling ",(0,a.kt)("a",{parentName:"p",href:"https://api.github.com/users/Elfocrash"},"https://api.github.com/users/Elfocrash"),". "),(0,a.kt)("p",null,"The response looks like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "login": "Elfocrash",\n  "id": 8199968,\n  "node_id": "MDQ6VXNlcjgxOTk5Njg=",\n  "avatar_url": "https://avatars.githubusercontent.com/u/8199968?v=4",\n  "gravatar_id": "",\n  "url": "https://api.github.com/users/Elfocrash",\n  "html_url": "https://github.com/Elfocrash",\n  "followers_url": "https://api.github.com/users/Elfocrash/followers",\n  "following_url": "https://api.github.com/users/Elfocrash/following{/other_user}",\n  "gists_url": "https://api.github.com/users/Elfocrash/gists{/gist_id}",\n  "starred_url": "https://api.github.com/users/Elfocrash/starred{/owner}{/repo}",\n  "subscriptions_url": "https://api.github.com/users/Elfocrash/subscriptions",\n  "organizations_url": "https://api.github.com/users/Elfocrash/orgs",\n  "repos_url": "https://api.github.com/users/Elfocrash/repos",\n  "events_url": "https://api.github.com/users/Elfocrash/events{/privacy}",\n  "received_events_url": "https://api.github.com/users/Elfocrash/received_events",\n  "type": "User",\n  "site_admin": false,\n  "name": "Nick Chapsas",\n  "company": null,\n  "blog": "https://nickchapsas.com",\n  "location": "London, UK",\n  "email": null,\n  "hireable": null,\n  "bio": "I just like making stuff | Microsoft MVP",\n  "twitter_username": "nickchapsas",\n  "public_repos": 48,\n  "public_gists": 2,\n  "followers": 5752,\n  "following": 0,\n  "created_at": "2014-07-18T09:32:23Z",\n  "updated_at": "2022-08-10T14:00:41Z"\n}\n')),(0,a.kt)("p",null,"Now let's configure WireMock to return the same response object with the same status code and content type headers when the path ",(0,a.kt)("inlineCode",{parentName:"p"},"/users/Elfocrash")," is called."),(0,a.kt)("p",null,"The setup format is pretty simple. We use the ",(0,a.kt)("inlineCode",{parentName:"p"},"Given")," method on the ",(0,a.kt)("inlineCode",{parentName:"p"},"wiremockServer")," to define request criteria and the ",(0,a.kt)("inlineCode",{parentName:"p"},"RespondWith")," method to define the response."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"wiremockServer.Given().RespondWith();\n")),(0,a.kt)("p",null,"We can configure the path by adding the following in the ",(0,a.kt)("inlineCode",{parentName:"p"},"Given")," method."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'Request.Create().WithPath("/users/Elfocrash").UsingGet()\n')),(0,a.kt)("p",null,"And we can configure the response by adding the following in the ",(0,a.kt)("inlineCode",{parentName:"p"},"RespondsWith")," method:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'Response.Create()\n        .WithStatusCode(200)\n        .WithHeader("Content-Type", "application/json; charset=utf-8")\n        .WithBody(@"{\n    ""login"": ""Elfocrash"",\n    ""id"": 8199968,\n    ""node_id"": ""MDQ6VXNlcjgxOTk5Njg="",\n    ""avatar_url"": ""https://avatars.githubusercontent.com/u/8199968?v=4"",\n    ""gravatar_id"": """",\n    ""url"": ""https://api.github.com/users/Elfocrash"",\n    ""html_url"": ""https://github.com/Elfocrash"",\n    ""followers_url"": ""https://api.github.com/users/Elfocrash/followers"",\n    ""following_url"": ""https://api.github.com/users/Elfocrash/following{/other_user}"",\n    ""gists_url"": ""https://api.github.com/users/Elfocrash/gists{/gist_id}"",\n    ""starred_url"": ""https://api.github.com/users/Elfocrash/starred{/owner}{/repo}"",\n    ""subscriptions_url"": ""https://api.github.com/users/Elfocrash/subscriptions"",\n    ""organizations_url"": ""https://api.github.com/users/Elfocrash/orgs"",\n    ""repos_url"": ""https://api.github.com/users/Elfocrash/repos"",\n    ""events_url"": ""https://api.github.com/users/Elfocrash/events{/privacy}"",\n    ""received_events_url"": ""https://api.github.com/users/Elfocrash/received_events"",\n    ""type"": ""User"",\n    ""site_admin"": false,\n    ""name"": ""Nick Chapsas"",\n    ""company"": null,\n    ""blog"": ""https://nickchapsas.com"",\n    ""location"": ""London, UK"",\n    ""email"": null,\n    ""hireable"": null,\n    ""bio"": ""I just like making stuff | Microsoft MVP"",\n    ""twitter_username"": ""nickchapsas"",\n    ""public_repos"": 48,\n    ""public_gists"": 2,\n    ""followers"": 5752,\n    ""following"": 0,\n    ""created_at"": ""2014-07-18T09:32:23Z"",\n    ""updated_at"": ""2022-08-10T14:00:41Z""\n}")\n')),(0,a.kt)("p",null,"And that's it! Run and call the API at ",(0,a.kt)("inlineCode",{parentName:"p"},"/users/Elfocrash"),".\nNow the fake GitHub API responds with the same content, status code and headers that the real one does."),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Some of the headers have been omitted for the sake of brevity. You can add them as you need them.")),(0,a.kt)("h3",{id:"creating-the-fake-githubapiserver"},"Creating the fake ",(0,a.kt)("inlineCode",{parentName:"h3"},"GitHubApiServer")),(0,a.kt)("p",null,"The approach we are going to follow is very similar to the approach we followed with Testcontainers.\nThe goal is to run the WireMock.NET instance during integration test startup in the WebApplicationFactory,\nconfigure the web server to use WireMock.NET instead of the GitHub API and then shut it down when the tests are done."),(0,a.kt)("p",null,'First let\'s start by creating a class that will contain all the logic related to the "mock" GitHub API server that WireMock.NET will be powering.\nSince this class need to be carefully disposed, we will also implement the ',(0,a.kt)("inlineCode",{parentName:"p"},"IDisposable")," interface. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="GitHubApiServer.cs"',title:'"GitHubApiServer.cs"'},"public class GitHubApiServer : IDisposable\n{\n    public void Dispose()\n    {\n        \n    }\n}\n")),(0,a.kt)("p",null,"Now let's add the ",(0,a.kt)("inlineCode",{parentName:"p"},"WireMockServer"),", a property to get the server URL, a ",(0,a.kt)("inlineCode",{parentName:"p"},"Start")," method and implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"Dispose")," method."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="GitHubApiServer.cs"',title:'"GitHubApiServer.cs"'},"public class GitHubApiServer : IDisposable\n{\n    private WireMockServer _server;\n\n    public string Url => _server.Url!;\n\n    public void Start()\n    {\n        _server = WireMockServer.Start();\n    }\n    \n    public void Dispose()\n    {\n        _server.Stop();\n        _server.Dispose();\n    }\n}\n")),(0,a.kt)("p",null,"Now the only thing that's left to implement is a ",(0,a.kt)("inlineCode",{parentName:"p"},"SetupUser")," method that sets up a GitHub user by username."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'public void SetupUser(string username)\n{\n    _server.Given(Request.Create()\n        .WithPath($"/users/{username}")\n        .UsingGet())\n        .RespondWith(Response.Create()\n            .WithBody(GenerateGitHubUserResponseBody(username))\n            .WithHeader("content-type", "application/json; charset=utf-8")\n            .WithStatusCode(200));\n}\n\nprivate static string GenerateGitHubUserResponseBody(string username)\n{\n    return $@"{{\n  ""login"": ""{username}"",\n  ""id"": 67104228,\n  ""node_id"": ""MDQ6VXNlcjY3MTA0MjI4"",\n  ""avatar_url"": ""https://avatars.githubusercontent.com/u/67104228?v=4"",\n  ""gravatar_id"": """",\n  ""url"": ""https://api.github.com/users/{username}"",\n  ""html_url"": ""https://github.com/{username}"",\n  ""followers_url"": ""https://api.github.com/users/{username}/followers"",\n  ""following_url"": ""https://api.github.com/users/{username}/following{{/other_user}}"",\n  ""gists_url"": ""https://api.github.com/users/{username}/gists{{/gist_id}}"",\n  ""starred_url"": ""https://api.github.com/users/{username}/starred{{/owner}}{{/repo}}"",\n  ""subscriptions_url"": ""https://api.github.com/users/{username}/subscriptions"",\n  ""organizations_url"": ""https://api.github.com/users/{username}/orgs"",\n  ""repos_url"": ""https://api.github.com/users/{username}/repos"",\n  ""events_url"": ""https://api.github.com/users/{username}/events{{/privacy}}"",\n  ""received_events_url"": ""https://api.github.com/users/{username}/received_events"",\n  ""type"": ""User"",\n  ""site_admin"": false,\n  ""name"": null,\n  ""company"": null,\n  ""blog"": """",\n  ""location"": null,\n  ""email"": null,\n  ""hireable"": null,\n  ""bio"": null,\n  ""twitter_username"": null,\n  ""public_repos"": 0,\n  ""public_gists"": 0,\n  ""followers"": 0,\n  ""following"": 0,\n  ""created_at"": ""2020-06-18T11:47:58Z"",\n  ""updated_at"": ""2020-06-18T11:47:58Z""\n}}";\n}\n')),(0,a.kt)("p",null,"And that's it! You can go even more granular and configure more things on the response body, depending on what you need,\nbut since we only care about the status code in our API we will leave it here. The reason why we won't implement the 404 NotFound\nfor user that are not configured is because WireMock will return 404 for those unimplemented users anyway so we don't need to."),(0,a.kt)("h3",{id:"replacing-the-real-server-with-the-fake-one"},"Replacing the real server with the fake one"),(0,a.kt)("p",null,"We can now use the ",(0,a.kt)("inlineCode",{parentName:"p"},"GitHubApiServer")," to start the server and use the ",(0,a.kt)("inlineCode",{parentName:"p"},"ConfigureTestServices")," method to replace the old GitHub BaseURL with our own."),(0,a.kt)("p",null,"First let's great a constant username for a valid GitHub user."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'public const string ValidGithubUser = "validuser";\n')),(0,a.kt)("p",null,"Then let's create the instance of the GitHubApiServer:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"private readonly GitHubApiServer _gitHubApiServer = new ();\n")),(0,a.kt)("p",null,"Since there can only be one named client with the same name in ASP.NET Core, instead of removing the already registered HttpClient we can just add our own on top of it.\nThis action will replace the previous one."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'services.AddHttpClient("GitHub", httpClient =>\n{\n    httpClient.BaseAddress = new Uri(_gitHubApiServer.Url);\n    httpClient.DefaultRequestHeaders.Add(\n        HeaderNames.Accept, "application/vnd.github.v3+json");\n    httpClient.DefaultRequestHeaders.Add(\n        HeaderNames.UserAgent, $"Workshop-{Environment.MachineName}");\n});\n')),(0,a.kt)("p",null,"The only thing left to do is to update the ",(0,a.kt)("inlineCode",{parentName:"p"},"InitializeAsync")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"DisposeAsync")," methods to include the start, setup and stop of the fake GitHub API server."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public async Task InitializeAsync()\n{\n    _gitHubApiServer.Start();\n    _gitHubApiServer.SetupUser(ValidGithubUser);\n    await _dbContainer.StartAsync();\n    HttpClient = CreateClient();\n    _dbConnection = new NpgsqlConnection(_dbContainer.ConnectionString);\n    await InitializeRespawner();\n}\n\npublic new async Task DisposeAsync()\n{\n    await _dbContainer.StopAsync();\n    _gitHubApiServer.Dispose();\n}\n")),(0,a.kt)("p",null,"Now let's run our test and..."),(0,a.kt)("p",null,(0,a.kt)("img",{src:n(5842).Z,width:"1177",height:"403"})),(0,a.kt)("p",null,"...they failed! Which it fine because we are using GitHub username ",(0,a.kt)("inlineCode",{parentName:"p"},"nickchapsas")," but we configured the valid user to be called ",(0,a.kt)("inlineCode",{parentName:"p"},"validuser"),"."),(0,a.kt)("p",null,"It's up to you to call the valid user whatever you want. I'll just update the name to ",(0,a.kt)("inlineCode",{parentName:"p"},"nickchapsas")," and run the tests again and..."),(0,a.kt)("p",null,(0,a.kt)("img",{src:n(3934).Z,width:"904",height:"424"})),(0,a.kt)("p",null,"...voila! All tests pass without calling the real GitHub API but the one we run. Fully isolated and fully controlled integration tests."),(0,a.kt)("h3",{id:"exercise-write-two-integration-tests"},"Exercise: Write two integration tests"),(0,a.kt)("p",null,'Since we have the "happy path" implemented, let\'s implement the two unhappy paths.'),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"Create_ShouldReturnBadRequest_WhenGitHubUserDoesNotExist")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("inlineCode",{parentName:"li"},"Create_ShouldReturnInternalServerError_WhenGitHubIsThrottled"))),(0,a.kt)("p",null,"In the case of ",(0,a.kt)("inlineCode",{parentName:"p"},"NotFound")," you don't need to setup the ",(0,a.kt)("inlineCode",{parentName:"p"},"NotFound")," user. This is the response body of the ",(0,a.kt)("inlineCode",{parentName:"p"},"BadRequest")," when a GitHub user does not exist:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",\n    "title": "One or more validation errors occurred.",\n    "status": 400,\n    "traceId": "0HMKR48DE4O5U:00000004",\n    "errors": {\n        "Customer": [\n            "There is no GitHub user with username nickchapsas"\n        ]\n    }\n}\n')),(0,a.kt)("p",null,"For the ",(0,a.kt)("inlineCode",{parentName:"p"},"InternalServerError")," test, GitHub will respond with a ",(0,a.kt)("inlineCode",{parentName:"p"},"403 rate limit exceeded")," on throttled requests with response body:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "message": "API rate limit exceeded for <your-ip-address>. (But here\'s the good news: Authenticated requests get a higher rate limit. Check out the documentation for more details.)",\n    "documentation_url": "https://docs.github.com/rest/overview/resources-in-the-rest-api#rate-limiting"\n}\n')),(0,a.kt)("h4",{id:"solutions"},"Solutions"),(0,a.kt)("p",null,"Only expand the solutions after you've tried to solve the problem yourself. Practice makes perfect and you only learn by doing."),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Create_ReturnsBadRequest_WhenGitHubUserDoesNotExist"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'[Fact]\npublic async Task Create_ShouldReturnBadRequest_WhenGitHubUserDoesNotExist()\n{\n    // Arrange\n    var request = new CustomerRequest\n    {\n        Email = "nick@chapsas.com",\n        FullName = "Nick Chapsas",\n        DateOfBirth = new DateTime(1993, 01, 01),\n        GitHubUsername = "missing"\n    };\n\n    // Act\n    var response = await _client.PostAsJsonAsync("customers", request);\n\n    // Assert\n    response.StatusCode.Should().Be(HttpStatusCode.BadRequest);\n\n    var problemDetails = await response.Content.ReadFromJsonAsync<ValidationProblemDetails>();\n    problemDetails!.Errors["Customer"].Should().Equal("There is no GitHub user with username missing");\n}\n'))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Create_ReturnsInternalServerError_WhenGitHubIsThrottled"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},'[Fact]\npublic async Task Create_ShouldReturnInternalServerError_WhenGitHubIsThrottled()\n{\n    // Arrange\n    var request = new CustomerRequest\n    {\n        Email = "nick@chapsas.com",\n        FullName = "Nick Chapsas",\n        DateOfBirth = new DateTime(1993, 01, 01),\n        GitHubUsername = "throttled"\n    };\n\n    // Act\n    var response = await _client.PostAsJsonAsync("customers", request);\n\n    // Assert\n    response.StatusCode.Should().Be(HttpStatusCode.InternalServerError);\n}\n'))),(0,a.kt)("h3",{id:"quick-refactoring"},"Quick refactoring"),(0,a.kt)("p",null,"Refactoring our tests and structure as we go is part of the development process.\nThe main thing I am not a fan of is that the ",(0,a.kt)("inlineCode",{parentName:"p"},"CustomerApiFactory"),' class is responsible for setting up "good" and ',(0,a.kt)("inlineCode",{parentName:"p"},"throttled")," GitHub users.\nThis should not be its responsibility. It should be the test class or the test itself that sets up the user it wants to call."),(0,a.kt)("p",null,"Let's refactor!"),(0,a.kt)("p",null,"First we will expose the ",(0,a.kt)("inlineCode",{parentName:"p"},"GitHubApiServer")," through a property with a public getter. This means that we will delete the old field."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp"},"public GitHubApiServer GitHubApiServer { get; } = new();\n")),(0,a.kt)("p",null,"We can now use this property as a field in our Test classes and use it to setup test data on a per-test basis.\nAnd that's it. All our tests should now still pass but things live in more appropriate places."))}c.isMDXComponent=!0},5842:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/failed-c924ff7b7aae8d9f6bb274aa5d3e4556.png"},3934:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/pass-32f6d01f827480569309fab3c8cf71b9.png"}}]);