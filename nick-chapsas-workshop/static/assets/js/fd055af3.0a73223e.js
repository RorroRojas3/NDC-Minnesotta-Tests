"use strict";(self.webpackChunktesting_workshop=self.webpackChunktesting_workshop||[]).push([[1224],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=l(n),u=i,g=h["".concat(c,".").concat(u)]||h[u]||p[u]||o;return n?a.createElement(g,r(r({ref:t},d),{},{components:n})):a.createElement(g,r({ref:t},d))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var l=2;l<o;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2072:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(7462),i=(n(7294),n(3905));const o={description:"Using Docker to create databases when we need them"},r="Creating databases on demand",s={unversionedId:"integration-testing/api/databases-on-demand",id:"integration-testing/api/databases-on-demand",title:"Creating databases on demand",description:"Using Docker to create databases when we need them",source:"@site/docs/integration-testing/api/databases-on-demand.md",sourceDirName:"integration-testing/api",slug:"/integration-testing/api/databases-on-demand",permalink:"/integration-testing/api/databases-on-demand",draft:!1,tags:[],version:"current",frontMatter:{description:"Using Docker to create databases when we need them"},sidebar:"docs",previous:{title:"Perfecting database cleanup",permalink:"/integration-testing/api/perfecting-data-cleanup"},next:{title:"Dealing with third-party APIs",permalink:"/integration-testing/api/dealing-with-apis"}},c={},l=[{value:"Introducing Docker",id:"introducing-docker",level:2},{value:"Running Docker Containers with C#",id:"running-docker-containers-with-c",level:2},{value:"Defining the Testcontainer",id:"defining-the-testcontainer",level:3},{value:"Re-wiring the database connection",id:"re-wiring-the-database-connection",level:3},{value:"Using Database-specific Test containers",id:"using-database-specific-test-containers",level:3}],d={toc:l};function p(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"creating-databases-on-demand"},"Creating databases on demand"),(0,i.kt)("p",null,"One of the biggest, if not the biggest, problems we need to deal with when we are running integration tests is having a database in place for the tests to run against.\nThis datastore needs to be controlled for those tests to run and satisfy specific criteria such as containing specific data for the tests to run."),(0,i.kt)("p",null,"Managing and maintaining a database that runs at all times just for the integration tests to run against, is not a scalable option.\nWouldn't it be better if we could create an isolated database only when the tests run and then shut it down once the tests pass or fail?"),(0,i.kt)("p",null,"Well what a coincidence! That's exactly what we'll learn how to do."),(0,i.kt)("h2",{id:"introducing-docker"},"Introducing Docker"),(0,i.kt)("p",null,"Docker is a containerization technology that allows us to run services in a controlled and self-contained fashion.\nWe can run anything with it, from web services, to reverse proxies, to databases. In fact this is how I've been running the Postgres database that I've been using until now.\nDocker containers are lightweight so we can create and destroy them on demand very easily.\nSuch a concept lends itself really nicely for our integration testing usecase."),(0,i.kt)("h2",{id:"running-docker-containers-with-c"},"Running Docker Containers with C#"),(0,i.kt)("p",null,"The first thing we need to do is to find a way to control Docker with C#.\nThere are a couple of main ways and over the course of this workshop we will see both. We will start however with the simplest one for our usecase."),(0,i.kt)("p",null,"We will use a Nuget package called ",(0,i.kt)("inlineCode",{parentName:"p"},"Testcontainers"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-commandline"},"dotnet add package Testcontainers\n")),(0,i.kt)("p",null,"We can now use the ",(0,i.kt)("inlineCode",{parentName:"p"},"TestcontainersContainer")," class in our code to define the container that we need.\nSince the ",(0,i.kt)("inlineCode",{parentName:"p"},"CustomerApiFactory")," is responsible for managing the lifetime of our tests, we will add the container creation and shutdown code there."),(0,i.kt)("h3",{id:"defining-the-testcontainer"},"Defining the Testcontainer"),(0,i.kt)("p",null,"As a reminder, this is how we have defined our database in the docker-compose.yml file that we used to run it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"image: postgres:latest\nrestart: always\nenvironment:\n  - POSTGRES_USER=workshop\n  - POSTGRES_PASSWORD=changeme\n  - POSTGRES_DB=mydb\nports:\n  - '5432:5432'\n")),(0,i.kt)("p",null,"To define the same thing using Testcontainers we need to created a ",(0,i.kt)("inlineCode",{parentName:"p"},"TestcontainersContainer")," object and use the ",(0,i.kt)("inlineCode",{parentName:"p"},"TestcontainersBuilder<TestcontainersContainer>()"),"'s fluent extensions to define those items."),(0,i.kt)("p",null,"For example to define the ",(0,i.kt)("inlineCode",{parentName:"p"},"image: postgres:latest")," we need to call the ",(0,i.kt)("inlineCode",{parentName:"p"},"WithImage")," method."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'private readonly TestcontainersContainer _dbContainer =\n    new TestcontainersBuilder<TestcontainersContainer>()\n        .WithImage("postgres:latest")\n        .WithEnvironment("POSTGRES_USER", "workshop")\n        .WithEnvironment("POSTGRES_PASSWORD", "changeme")\n        .WithEnvironment("POSTGRES_DB", "mydb")\n        .WithPortBinding(5555, 5432)\n        .WithWaitStrategy(Wait.ForUnixContainer().UntilPortIsAvailable(5432))\n        .Build();\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"WithWaitStrategy")," ensures that the port is ready before the tests continue. This makes sure the tests won't run against a database container that hasn't started yet."),(0,i.kt)("p",null,"Now to start the container we need to call the ",(0,i.kt)("inlineCode",{parentName:"p"},"StartAsync")," method of the object in the ",(0,i.kt)("inlineCode",{parentName:"p"},"InitializeAsync")," method and the ",(0,i.kt)("inlineCode",{parentName:"p"},"StopAsync")," method in the ",(0,i.kt)("inlineCode",{parentName:"p"},"DisposeAsync")," one. "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"public async Task InitializeAsync()\n{\n    await _dbContainer.StartAsync();\n    HttpClient = CreateClient();\n    _dbConnection = new NpgsqlConnection(_dbContainer.ConnectionString);\n    await InitializeRespawner();\n}\n\npublic new async Task DisposeAsync() => await _dbContainer.StopAsync();\n")),(0,i.kt)("p",null,"But wait a second. How can we configure our API to use the new connection to this ephemeral database?"),(0,i.kt)("h3",{id:"re-wiring-the-database-connection"},"Re-wiring the database connection"),(0,i.kt)("p",null,"Re-configuring the web application is extremely easy due to the ",(0,i.kt)("inlineCode",{parentName:"p"},"ConfigureWebHost")," that we have in the custom WebApplicationFactory."),(0,i.kt)("p",null,"We can simply call the ",(0,i.kt)("inlineCode",{parentName:"p"},"builder.ConfigureTestServices")," method and manipulate the service container in any way that we want for our testing.\nIn our case we want to remove the existing ",(0,i.kt)("inlineCode",{parentName:"p"},"IDbConnectionFactory")," and add one that points to our Docker database."),(0,i.kt)("p",null,"We can do that with a couple of line of code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'builder.ConfigureTestServices(services =>\n{\n    services.RemoveAll(typeof(IDbConnectionFactory));\n    services.AddSingleton<IDbConnectionFactory>(_ => new NpgsqlConnectionFactory("Server=localhost;Port=5555;Database=mydb;User ID=workshop;Password=changeme;"));\n});\n')),(0,i.kt)("p",null,"Now if we run our tests you can see that all of them pass, without having a database running beforehand and the database created for the tests is deleted immediately after the tests run."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(1472).Z,width:"898",height:"461"})),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(2841).Z,width:"996",height:"358"})),(0,i.kt)("p",null,"And that's it! We now create a database on demand just for out tests and we tear it down after we are done."),(0,i.kt)("h3",{id:"using-database-specific-test-containers"},"Using Database-specific Test containers"),(0,i.kt)("p",null,"Testcontainers can help us run containers very easily as we've already seen but they also have specific code for very common container images such as database.\nThese pre-defined containers can streamline our code a lot."),(0,i.kt)("p",null,"For example in our previous example, we hardcoded the port ",(0,i.kt)("inlineCode",{parentName:"p"},"5555")," both in the container definition and the connection string.\nHowever, we don't know for a fact that this port will always be free on our machine. We could write code that deals with that but we don't need to."),(0,i.kt)("p",null,"We can now change our ",(0,i.kt)("inlineCode",{parentName:"p"},"TestcontainersContainer")," to be of type ",(0,i.kt)("inlineCode",{parentName:"p"},"TestcontainerDatabase")," and use a builder of type ",(0,i.kt)("inlineCode",{parentName:"p"},"TestcontainersBuilder<PostgreSqlTestcontainer>()"),".\nThis allows us to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"WithDatabase")," extension method which accepts a ",(0,i.kt)("inlineCode",{parentName:"p"},"PostgreSqlTestcontainerConfiguration")," object."),(0,i.kt)("p",null,"Now all the code we need to define the Postgres database looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'private readonly TestcontainerDatabase _dbContainer =\n    new TestcontainersBuilder<PostgreSqlTestcontainer>()\n        .WithDatabase(new PostgreSqlTestcontainerConfiguration\n        {\n            Database = "mydb",\n            Username = "workshop",\n            Password = "changeme"\n        }).Build();\n')),(0,i.kt)("p",null,"And what's even better, we no longer need to hardcode and connection strings or ports. Testcontainers will manage all that for us."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},"builder.ConfigureTestServices(services =>\n{\n    services.RemoveAll(typeof(IDbConnectionFactory));\n    services.AddSingleton<IDbConnectionFactory>(_ => new NpgsqlConnectionFactory(_dbContainer.ConnectionString));\n});\n")),(0,i.kt)("p",null,"Now simply run the tests and watch them pass without you needing to have a database in place."))}p.isMDXComponent=!0},2841:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/test-specific-db-7319a38ecee7d1b4285d6135535926d2.png"},1472:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/tests-pass-25a4e84eb380cc954d6b191ea3831668.png"}}]);