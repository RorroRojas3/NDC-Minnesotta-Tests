"use strict";(self.webpackChunktesting_workshop=self.webpackChunktesting_workshop||[]).push([[8449],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),m=u(n),d=r,h=m["".concat(s,".").concat(d)]||m[d]||c[d]||i;return n?a.createElement(h,l(l({ref:t},p),{},{components:n})):a.createElement(h,l({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=m;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var u=2;u<i;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3002:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var a=n(7462),r=(n(7294),n(3905));const i={description:"Making our tests more flexible"},l="One test, multiple test cases",o={unversionedId:"unit-testing/getting-started/multiple-test-params",id:"unit-testing/getting-started/multiple-test-params",title:"One test, multiple test cases",description:"Making our tests more flexible",source:"@site/docs/unit-testing/getting-started/multiple-test-params.md",sourceDirName:"unit-testing/getting-started",slug:"/unit-testing/getting-started/multiple-test-params",permalink:"/unit-testing/getting-started/multiple-test-params",draft:!1,tags:[],version:"current",frontMatter:{description:"Making our tests more flexible"},sidebar:"docs",previous:{title:"Exercise: Test the calculator",permalink:"/unit-testing/getting-started/calculator-exercise"},next:{title:"Deep dive",permalink:"/category/deep-dive"}},s={},u=[{value:"The problem with <code>[Fact]</code>",id:"the-problem-with-fact",level:2},{value:"InlineData",id:"inlinedata",level:2},{value:"MemberData",id:"memberdata",level:2},{value:"ClassData",id:"classdata",level:2}],p={toc:u};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"one-test-multiple-test-cases"},"One test, multiple test cases"),(0,r.kt)("h2",{id:"the-problem-with-fact"},"The problem with ",(0,r.kt)("inlineCode",{parentName:"h2"},"[Fact]")),(0,r.kt)("p",null,"As you might have noticed until now, we've been using the ",(0,r.kt)("inlineCode",{parentName:"p"},"[Fact]")," attribute to create tests that are detected by xUnit."),(0,r.kt)("p",null,"There is however a pretty interesting problem. In several of the tests, the only thing that changes are the parameters that the test is invoked with.\nThe code of the test itself stays the same. This has the drawback of a lot of duplicated code. xUnit has a solution for that."),(0,r.kt)("p",null,"Instead of creating a test with the ",(0,r.kt)("inlineCode",{parentName:"p"},"[Fact]")," attribute we can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"[Theory]")," attribute.\nThe test will still be discovered by xUnit but now we have the option to provide multiple parameters at once."),(0,r.kt)("h2",{id:"inlinedata"},"InlineData"),(0,r.kt)("p",null,"One of our options is to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"[InlineData]")," attribute to specify just a few test cases in a single test.\n",(0,r.kt)("inlineCode",{parentName:"p"},"[InlineData]")," accepts as many parameters as the method of our test."),(0,r.kt)("p",null,"For example if we change this test's signature from this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public void Subtract_ShouldSubtractTwoNumbers_WhenTheNumbersAreIntegers()\n")),(0,r.kt)("p",null,"To this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public void Subtract_ShouldSubtractTwoNumbers_WhenTheNumbersAreIntegers(int a, int b, int final)\n")),(0,r.kt)("p",null,"Then we can add an ",(0,r.kt)("inlineCode",{parentName:"p"},"[InlineData]")," attribute with 3 parameters like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[InlineData(5, 3, 2)]\npublic void Subtract_ShouldSubtractTwoNumbers_WhenTheNumbersAreIntegers(int a, int b, int final)\n")),(0,r.kt)("p",null,"In this example 5 is mapped to ",(0,r.kt)("inlineCode",{parentName:"p"},"a"),", 3 is mapped to ",(0,r.kt)("inlineCode",{parentName:"p"},"b")," and 2 is mapped to ",(0,r.kt)("inlineCode",{parentName:"p"},"final"),".\nThen we simply use those parameters in our test and our test is now converted to N tests where N is the amount of ",(0,r.kt)("inlineCode",{parentName:"p"},"[InlineData]")," attributes I apply to the method."),(0,r.kt)("p",null,"For example, the following is 3 individual tests, all using the same code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[Theory]\n[InlineData(5, 3, 2)]\n[InlineData(5, 5, 0)]\n[InlineData(3, 5, -2)]\npublic void Subtract_ShouldSubtractTwoNumbers_WhenTheNumbersAreIntegers(int a, int b, int final)\n{\n    // Arrange\n    var calculator = new IntCalculator();\n\n    // Act\n    var result = calculator.Subtract(a, b);\n\n    // Assert\n    result.Should().Be(final);\n}\n")),(0,r.kt)("h2",{id:"memberdata"},"MemberData"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"[InlineData]")," is a great way to parameterize your tests but what if you want your test cases to be extracted somewhere else so they don't clutter your main test?\nThis is where the ",(0,r.kt)("inlineCode",{parentName:"p"},"[MemberData]")," attribute comes in."),(0,r.kt)("p",null,"First we need to create a new method that returns ",(0,r.kt)("inlineCode",{parentName:"p"},"IEnumerable<object?[]>"),". The implementation of this method is completely up to us.\nThe most common usecase is to just move our test cases in an in memory array so our example from above will look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public static IEnumerable<object[]> SubtractData => new List<object[]>\n{\n    new object[] { 5, 3, 2 },\n    new object[] { 5, 5, 0 },\n    new object[] { 3, 5, -2 }\n};\n")),(0,r.kt)("p",null,"However, if you wanted to have a file where you have your test cases in and write some code that loads them on test execution, you totally can. I don't recommend it in this case, but it is an option."),(0,r.kt)("p",null,"In order for our test to use the extracted cases all we need to do is use the ",(0,r.kt)("inlineCode",{parentName:"p"},"[MemberData]")," attribute and point ot our property by name like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[Theory]    \n[MemberData(nameof(SubtractData))]\npublic void Subtract_ShouldSubtractTwoNumbers_WhenTheNumbersAreIntegers(int a, int b, int final)\n")),(0,r.kt)("h2",{id:"classdata"},"ClassData"),(0,r.kt)("p",null,"Similar to ",(0,r.kt)("inlineCode",{parentName:"p"},"[MemberData]"),", the ",(0,r.kt)("inlineCode",{parentName:"p"},"[ClassData]")," attribute takes the same concept and it abstract it into a class instead of a method."),(0,r.kt)("p",null,"To do that we first need to create a new class that implements ",(0,r.kt)("inlineCode",{parentName:"p"},"IEnumerable<object?[]>"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public class SubtractData : IEnumerable<object[]>\n")),(0,r.kt)("p",null,"Due to the implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"IEnumerable")," interface we will need to implement two methods."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"public IEnumerator<object?[]> GetEnumerator()")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"IEnumerator IEnumerable.GetEnumerator()"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"IEnumerator IEnumerable.GetEnumerator()")," will simply point to the ",(0,r.kt)("inlineCode",{parentName:"p"},"public IEnumerator<object?[]> GetEnumerator()")," method like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"IEnumerator IEnumerable.GetEnumerator()\n{\n    return GetEnumerator();\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"public IEnumerator<object?[]> GetEnumerator()")," will now need to return the data in the same way that the ",(0,r.kt)("inlineCode",{parentName:"p"},"[MemberData]")," version did.\nIn this case I am going to use the ",(0,r.kt)("inlineCode",{parentName:"p"},"yield")," keyword. It will result to the following implementation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"public IEnumerator<object?[]> GetEnumerator()\n{\n    yield return new object[] { 5, 3, 2 };\n    yield return new object[] { 5, 5, 0 };\n    yield return new object[] { 3, 5, -2 };\n}\n")),(0,r.kt)("p",null,"The full implementation of ",(0,r.kt)("inlineCode",{parentName:"p"},"SubtractData.cs")," is the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="SubtractData.cs"',title:'"SubtractData.cs"'},"public class SubtractData : IEnumerable<object?[]>\n{\n    public IEnumerator<object?[]> GetEnumerator()\n    {\n        yield return new object[] { 5, 3, 2 };\n        yield return new object[] { 5, 5, 0 };\n        yield return new object[] { 3, 5, -2 };\n    }\n\n    IEnumerator IEnumerable.GetEnumerator()\n    {\n        return GetEnumerator();\n    }\n}\n")),(0,r.kt)("p",null,"We can now apply the ",(0,r.kt)("inlineCode",{parentName:"p"},"[ClassData]")," attribute to the test method and point to the type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"SubtractData")," class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp"},"[Theory]\n[ClassData(typeof(SubtractData))]\npublic void Subtract_ShouldSubtractTwoNumbers_WhenTheNumbersAreIntegers(int a, int b, int final)\n")),(0,r.kt)("p",null,"And that's it. Now our data will be loaded from the SubtractData class."))}c.isMDXComponent=!0}}]);