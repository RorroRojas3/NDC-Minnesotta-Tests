"use strict";(self.webpackChunktesting_workshop=self.webpackChunktesting_workshop||[]).push([[8136],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),d=i,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||a;return n?r.createElement(h,o(o({ref:t},c),{},{components:n})):r.createElement(h,o({ref:t},c))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<a;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1956:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>p});var r=n(7462),i=(n(7294),n(3905));const a={description:"Writing tests for internal items can be challenging"},o="Testing internals",s={unversionedId:"unit-testing/deep-dive/testing-internals",id:"unit-testing/deep-dive/testing-internals",title:"Testing internals",description:"Writing tests for internal items can be challenging",source:"@site/docs/unit-testing/deep-dive/testing-internals.md",sourceDirName:"unit-testing/deep-dive",slug:"/unit-testing/deep-dive/testing-internals",permalink:"/unit-testing/deep-dive/testing-internals",draft:!1,tags:[],version:"current",frontMatter:{description:"Writing tests for internal items can be challenging"},sidebar:"docs",previous:{title:"Dealing with time",permalink:"/unit-testing/deep-dive/dealing-with-time"},next:{title:"Exercise: Testing legacy projects",permalink:"/unit-testing/deep-dive/exercise-refactoring"}},l={},p=[{value:"The problem",id:"the-problem",level:2},{value:"The solution(s)",id:"the-solutions",level:2},{value:"The <code>[InternalsVisibleTo]</code> attribute",id:"the-internalsvisibleto-attribute",level:3},{value:"The <code>csproj</code> file",id:"the-csproj-file",level:3}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"testing-internals"},"Testing internals"),(0,i.kt)("h2",{id:"the-problem"},"The problem"),(0,i.kt)("p",null,"It is not uncommon, especially for library authors, to make several of their classes or methods as ",(0,i.kt)("inlineCode",{parentName:"p"},"internal"),".\nThe reason for doing so is simple. Some classes or methods might not need to be exposed outside of the assembly it lives in.\nThis makes them be excluded from the contract between the library author and the consumer and it means that the author can change them without worrying about whether the consumer is using them.\nAnother reason could be to simply provide a better developer experience. Why expose a method that you don't expect the consumer to use?"),(0,i.kt)("p",null,"Using the code from our previous example, if the Greeter class wasn't supposed to be exposed it would look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'internal class Greeter\n{\n    private readonly IDateTimeProvider _dateTimeProvider;\n\n    internal Greeter(IDateTimeProvider dateTimeProvider)\n    {\n        _dateTimeProvider = dateTimeProvider;\n    }\n\n    internal string GenerateGreetText()\n    {\n        var dateTimeNow = _dateTimeProvider.Now;\n        return dateTimeNow.Hour switch\n        {\n            >= 5 and < 12 => "Good morning",\n            >= 12 and < 18 => "Good afternoon",\n            _ => "Good evening"\n        };\n    }\n}\n')),(0,i.kt)("p",null,"Here is where this becomes problematic.\nIn order to unit test an assembly you need to refer to it in the test project and access the classes and methods you want to test.\nHowever, since some of the members you want to test are marked as ",(0,i.kt)("inlineCode",{parentName:"p"},"internal"),", we can't access them."),(0,i.kt)("h2",{id:"the-solutions"},"The solution(s)"),(0,i.kt)("p",null,"There are multiple solutions to this problem. They all lead to the same experience and ultimately code generated."),(0,i.kt)("h3",{id:"the-internalsvisibleto-attribute"},"The ",(0,i.kt)("inlineCode",{parentName:"h3"},"[InternalsVisibleTo]")," attribute"),(0,i.kt)("p",null,"The main way to make your internals visible to a different project is to drop a C# class file in your assembly and define the ",(0,i.kt)("inlineCode",{parentName:"p"},"[InternalsVisibleTo]")," attribute on the assembly level."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="InternalsVisible.cs"',title:'"InternalsVisible.cs"'},'using System.Runtime.CompilerServices;\n[assembly:InternalsVisibleTo("EdgeCases.Tests.Unit")]\n')),(0,i.kt)("p",null,"The text parameter of the ",(0,i.kt)("inlineCode",{parentName:"p"},"InternalsVisibleTo")," attribute is the name of the assembly you want to expose your internals to.\nWith that attribute added, the error go away."),(0,i.kt)("p",null,"However, if you are also using a mocking framework you should also have the following assembly expose its internals:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-csharp"},'[assembly:InternalsVisibleTo("DynamicProxyGenAssembly2")]\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"DynamicProxyGenAssembly2")," is an assembly generated during the execution of tests when internals need to be mocked. All mocking frameworks will use that name."),(0,i.kt)("h3",{id:"the-csproj-file"},"The ",(0,i.kt)("inlineCode",{parentName:"h3"},"csproj")," file"),(0,i.kt)("p",null,"In general, having to create a class file just to make your internals visible to the test project, can feel a bit out of place.\nA better idea is to move this logic into the csproj."),(0,i.kt)("p",null,"The first way we can do that is by using the ",(0,i.kt)("inlineCode",{parentName:"p"},"AssemblyAttribute")," functionality of the ",(0,i.kt)("inlineCode",{parentName:"p"},"csproj"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},'<ItemGroup>\n    <AssemblyAttribute Include="System.Runtime.CompilerServices.InternalsVisibleToAttribute">\n        <_Parameter1>EdgeCases.Tests.Unit</_Parameter1>\n    </AssemblyAttribute>\n</ItemGroup>\n')),(0,i.kt)("p",null,"Adding this snippet in our ",(0,i.kt)("inlineCode",{parentName:"p"},"csproj")," will make MSBuild to drop a compile-time generated line to the ",(0,i.kt)("inlineCode",{parentName:"p"},"EdgeCases.AssemblyInfo.cs")," file that lives in the ",(0,i.kt)("inlineCode",{parentName:"p"},"obj")," folder, giving the same experience."),(0,i.kt)("p",null,"However there is an even simpler way."),(0,i.kt)("p",null,"Simply use the ",(0,i.kt)("inlineCode",{parentName:"p"},"InternalsVisibleTo")," instruction to achieve the same thing."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},'<ItemGroup>\n    <InternalsVisibleTo Include="EdgeCases.Tests.Unit"/>\n</ItemGroup>\n')),(0,i.kt)("p",null,"This is a cleaner and more modern way of doing exactly the same thing as above."),(0,i.kt)("p",null,"Now the last thing we can do to make this even more generic is replace the project name with a parameter."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},'<ItemGroup>\n    <InternalsVisibleTo Include="$(AssemblyName).Tests.Unit" />\n    <InternalsVisibleTo Include="DynamicProxyGenAssembly2" />\n</ItemGroup>\n')),(0,i.kt)("p",null,"We can now have the exact same snippet in our ",(0,i.kt)("inlineCode",{parentName:"p"},"csproj"),", irrelevant from the project name, and be able to reuse it in a template to make internals visible to unit test projects."))}m.isMDXComponent=!0}}]);