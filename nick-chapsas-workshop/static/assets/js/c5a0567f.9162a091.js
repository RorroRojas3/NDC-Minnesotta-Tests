"use strict";(self.webpackChunktesting_workshop=self.webpackChunktesting_workshop||[]).push([[688],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),d=u(n),m=o,y=d["".concat(s,".").concat(m)]||d[m]||l[m]||a;return n?r.createElement(y,i(i({ref:t},p),{},{components:n})):r.createElement(y,i({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var u=2;u<a;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5153:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>l,frontMatter:()=>a,metadata:()=>c,toc:()=>u});var r=n(7462),o=(n(7294),n(3905));const a={description:"What is mocking and why we need it"},i="Introducing Mocking",c={unversionedId:"unit-testing/deep-dive/mocking-intro",id:"unit-testing/deep-dive/mocking-intro",title:"Introducing Mocking",description:"What is mocking and why we need it",source:"@site/docs/unit-testing/deep-dive/mocking-intro.md",sourceDirName:"unit-testing/deep-dive",slug:"/unit-testing/deep-dive/mocking-intro",permalink:"/unit-testing/deep-dive/mocking-intro",draft:!1,tags:[],version:"current",frontMatter:{description:"What is mocking and why we need it"},sidebar:"docs",previous:{title:"Trying to write a test",permalink:"/unit-testing/deep-dive/attempting-test"},next:{title:"Asserting exceptions",permalink:"/unit-testing/deep-dive/asserting-exceptions"}},s={},u=[],p={toc:u};function l(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"introducing-mocking"},"Introducing Mocking"),(0,o.kt)("p",null,"The idea of mocking is pretty simple. Since we are already injecting interfaces (or abstract classes) into our classes,\nwhy not use something that can create in-memory proxy implementations of those interfaces, instead of calling the real implementation?"),(0,o.kt)("p",null,"The main thing we are trying to do is to replace the real ",(0,o.kt)("inlineCode",{parentName:"p"},"IRatesRepository")," implementation that calls a database with something that doesn't.\nWe could just write our own, but then we need to also write code to handle every scenario in our tests.\nInstead of doing that we can add a mocking library in our test project and let it create in-memory proxies of the classes for use."),(0,o.kt)("p",null,"The mocking library we will be using is ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/nsubstitute/NSubstitute"},"NSubstitute")," and can be installed either via your Nuget client or by running the command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-commandline"},"dotnet add package NSubstitute\n")),(0,o.kt)("p",null,"Now we can use the ",(0,o.kt)("inlineCode",{parentName:"p"},"Substitute.For")," method to create a substitute or a mock implementation for our ",(0,o.kt)("inlineCode",{parentName:"p"},"IRatesRepository")," class:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="QuoteServiceTests.cs"',title:'"QuoteServiceTests.cs"'},"private readonly IRatesRepository _ratesRepository = Substitute.For<IRatesRepository>();\n")),(0,o.kt)("p",null,"Once we do that we can use a set of extension methods that NSubstitute provides to make the ",(0,o.kt)("inlineCode",{parentName:"p"},"IRatesRepository")," methods of our choice responds in a way that we expect them to."),(0,o.kt)("p",null,"In our case, instead of going to the database and getting the ",(0,o.kt)("inlineCode",{parentName:"p"},"FxRate")," for a currency, I would simply like the ",(0,o.kt)("inlineCode",{parentName:"p"},"GetRateAsync")," method to return a rate of ",(0,o.kt)("inlineCode",{parentName:"p"},"1.6")," when the ",(0,o.kt)("inlineCode",{parentName:"p"},"baseCurrency")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"GBP")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"quoteCurrency")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"USD"),".\nIn terms of code, the object I am expecting back looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'var fromCurrency = "GBP";\nvar toCurrency = "USD";\n\nvar expectedRate = new FxRate\n{\n    FromCurrency = fromCurrency,\n    ToCurrency = toCurrency,\n    TimestampUtc = DateTime.UtcNow,\n    Rate = 1.6m\n};\n')),(0,o.kt)("p",null,"In order to make the ",(0,o.kt)("inlineCode",{parentName:"p"},"GetRateAsync")," method of the ",(0,o.kt)("inlineCode",{parentName:"p"},"IRatesRepository")," to return that rate all we need to do is invoke it and chain the ",(0,o.kt)("inlineCode",{parentName:"p"},"Returns")," method with the expected rate."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"_ratesRepository.GetRateAsync(fromCurrency, toCurrency).Returns(expectedRate);\n")),(0,o.kt)("p",null,"And that's it! Now you can run the test and you will get a green checkmark \u2705."),(0,o.kt)("details",null,(0,o.kt)("summary",null,"The full GetQuoteAsync_ShouldReturnQuote_WhenCurrenciesAreValid code"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'[Fact]\npublic async Task GetQuoteAsync_ShouldReturnQuote_WhenCurrenciesAreValid()\n{\n    // Arrange\n    var fromCurrency = "GBP";\n    var toCurrency = "USD";\n    var amount = 100;\n    var expectedRate = new FxRate\n    {\n        FromCurrency = fromCurrency,\n        ToCurrency = toCurrency,\n        TimestampUtc = DateTime.UtcNow,\n        Rate = 1.6m\n    };\n\n    var expectedQuote = new ConversionQuote\n    {\n        BaseCurrency = fromCurrency,\n        QuoteCurrency = toCurrency,\n        BaseAmount = amount,\n        QuoteAmount = 160\n    };\n    \n    _ratesRepository.GetRateAsync(fromCurrency, toCurrency)\n        .Returns(expectedRate);\n    \n    // Act\n    var quote = await _sut.GetQuoteAsync(fromCurrency, toCurrency, amount);\n\n    // Assert\n    quote!.Should().BeEquivalentTo(expectedQuote);\n}\n'))))}l.isMDXComponent=!0}}]);