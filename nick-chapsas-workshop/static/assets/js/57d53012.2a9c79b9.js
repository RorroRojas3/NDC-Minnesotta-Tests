"use strict";(self.webpackChunktesting_workshop=self.webpackChunktesting_workshop||[]).push([[7362],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),m=a,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||o;return n?r.createElement(h,i(i({ref:t},c),{},{components:n})):r.createElement(h,i({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3872:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var r=n(7462),a=(n(7294),n(3905));const o={description:"Let's setup our test suite for UI testing"},i="Running the app for testing",s={unversionedId:"integration-testing/ui/running-for-testing",id:"integration-testing/ui/running-for-testing",title:"Running the app for testing",description:"Let's setup our test suite for UI testing",source:"@site/docs/integration-testing/ui/running-for-testing.md",sourceDirName:"integration-testing/ui",slug:"/integration-testing/ui/running-for-testing",permalink:"/integration-testing/ui/running-for-testing",draft:!1,tags:[],version:"current",frontMatter:{description:"Let's setup our test suite for UI testing"},sidebar:"docs",previous:{title:"The same, but different",permalink:"/integration-testing/ui/same-approach"},next:{title:"Bootstrapping our tests",permalink:"/integration-testing/ui/test-setup"}},l={},p=[{value:"The <code>docker-compose.integration.yml</code> file",id:"the-docker-composeintegrationyml-file",level:2}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"running-the-app-for-testing"},"Running the app for testing"),(0,a.kt)("h2",{id:"the-docker-composeintegrationyml-file"},"The ",(0,a.kt)("inlineCode",{parentName:"h2"},"docker-compose.integration.yml")," file"),(0,a.kt)("p",null,"Before we even take a look at the integration tests themselves, we need to take a look at what will drive all those tests in the first place,\nand that is the ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-compose.integration.yml")," file. This file will be used by our tests to run the database and the web app so we can run integration tests against it."),(0,a.kt)("p",null,"For the Web App we will use an image built for the tests using the Dockerfile that can be found in ",(0,a.kt)("inlineCode",{parentName:"p"},"Customers.WebApp"),".\nIt is mostly stock, except it has extra configuration so we can run the API with an SSL certificate."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-dockerfile",metastring:'title="Dockerfile"',title:'"Dockerfile"'},'FROM mcr.microsoft.com/dotnet/sdk:6.0 AS build-env\nWORKDIR /app\n\n# Copy everything\nCOPY . ./\n# Restore as distinct layers\nRUN dotnet restore\n# Build and publish a release\nRUN dotnet publish -c Release -o out\n\n# Build runtime image\nFROM mcr.microsoft.com/dotnet/aspnet:6.0\nWORKDIR /app\nCOPY --from=build-env /app/out .\n# Run this to generate it: dotnet dev-certs https -ep cert.pfx -p Test1234!\nCOPY ["cert.pfx", "/https/cert.pfx"]\nENTRYPOINT ["dotnet", "Customers.WebApp.dll"]\n')),(0,a.kt)("p",null,"With that in place we can start creating the skeleton of the ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-compose.integration.yml")," file."),(0,a.kt)("p",null,"First let's add the Postgres database that we will be using for the tests:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml",metastring:'title="docker-compose.integration.yml"',title:'"docker-compose.integration.yml"'},"version: '3.9'\n\nservices:\n\n  test-db:\n    image: postgres:latest\n    restart: always\n    environment:\n      - POSTGRES_USER=workshop\n      - POSTGRES_PASSWORD=changeme\n      - POSTGRES_DB=mydb\n    healthcheck:\n      test: [ \"CMD-SHELL\", \"pg_isready\" ]\n      interval: 2s\n      timeout: 5s\n      retries: 10\n    ports:\n      - '5435:5432'\n")),(0,a.kt)("p",null,"This looks largely the same as our regular ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-compose.yml")," with the only difference being that we have a ",(0,a.kt)("inlineCode",{parentName:"p"},"healthcheck")," in place.\nThis health check will run after the docker container has started running and will run the ",(0,a.kt)("inlineCode",{parentName:"p"},"pg_isready")," command ever 2 second for a total of 10 times to ensure that the database is ready to be used before we proceed.\nThis is done so we don't start the web app against a database that can't handle it, causing the app to fail on startup."),(0,a.kt)("p",null,"Now we can add the Web App service and configure it to use that healthcheck to ensure that the app container won't start unless the database is ready. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yml"},'test-app:\n    build: ../../src/Customers.WebApp\n    ports:\n      - "7780:443"\n      - "7779:80"\n    environment:\n      - ASPNETCORE_URLS=https://+:443;http://+:80\n      - ASPNETCORE_Kestrel__Certificates__Default__Password=Test1234!\n      - ASPNETCORE_Kestrel__Certificates__Default__Path=/https/cert.pfx\n      - ASPNETCORE_Environment=Production\n    depends_on: \n      test-db:\n        condition: service_healthy\n')),(0,a.kt)("p",null,"As you can see, the URLs, the certificate details and the environment that we want the app to run with as passed as environment variables.\nASP.NET Core accepts them because ",(0,a.kt)("inlineCode",{parentName:"p"},"ASPNETCORE_")," is a known prefix that we can use to pass this configuration."),(0,a.kt)("p",null,"But wait a second. How will we configure the new GitHub API URL and the new database connection string if we can't change the code of the Web App.\nIt's actually pretty simple. We can leverage the same \"Environment Variable as config\" mechanism of ASP.NET Core to pass our own variables."),(0,a.kt)("p",null,"We can do that by using the ",(0,a.kt)("inlineCode",{parentName:"p"},"Configuration.AddEnvironmentVariables")," method and use as a parameter the prefix of our choice."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Program.cs"',title:'"Program.cs"'},'builder.Configuration.AddEnvironmentVariables("CustomersWebApp_");\n')),(0,a.kt)("p",null,"This will ensure that only environment variables that start with ",(0,a.kt)("inlineCode",{parentName:"p"},"CustomersWebApp_")," will be loaded."),(0,a.kt)("p",null,"In order for ASP.NET Core to acknowledge them and treat them as application configuration we need to follow the standard underscore-based nesting structure of ASP.NET Core."),(0,a.kt)("p",null,"For example in order to configure this item:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "Database": {\n    "ConnectionString": "Server=localhost;Port=5432;Database=mydb;User ID=workshop;Password=changeme;"\n  }\n}\n')),(0,a.kt)("p",null,"We need to pass an environment variable named ",(0,a.kt)("inlineCode",{parentName:"p"},"Database__ConnectionString"),". Note that those are 2 underscores, not one.\nTo make this work with our Dockerfile and environment loading the final name needs to be ",(0,a.kt)("inlineCode",{parentName:"p"},"CustomersWebApp_Database__ConnectionString"),"."),(0,a.kt)("p",null,"With that in mind we can add the following 2 lines in the ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-compose.integration.yml")," file to configure the test database and the fake GitHub API:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"- CustomersWebApp_Database__ConnectionString=Server=test-db;Port=5432;Database=mydb;User ID=workshop;Password=changeme;\n- CustomersWebApp_GitHub__ApiBaseUrl=http://host.docker.internal:9850\n")),(0,a.kt)("p",null,"This makes the final ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-compose.integration.yml")," as follows: "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'version: \'3.9\'\n\nservices:\n\n  test-app:\n    build: ../../src/Customers.WebApp\n    ports:\n      - "7780:443"\n      - "7779:80"\n    environment:\n      - ASPNETCORE_URLS=https://+:443;http://+:80\n      - ASPNETCORE_Kestrel__Certificates__Default__Password=Test1234!\n      - ASPNETCORE_Kestrel__Certificates__Default__Path=/https/cert.pfx\n      - ASPNETCORE_Environment=Production\n      - CustomersWebApp_Database__ConnectionString=Server=test-db;Port=5432;Database=mydb;User ID=workshop;Password=changeme;\n      - CustomersWebApp_GitHub__ApiBaseUrl=http://host.docker.internal:9850\n    depends_on: \n      test-db:\n        condition: service_healthy\n\n  test-db:\n    image: postgres:latest\n    restart: always\n    environment:\n      - POSTGRES_USER=workshop\n      - POSTGRES_PASSWORD=changeme\n      - POSTGRES_DB=mydb\n    healthcheck:\n      test: [ "CMD-SHELL", "pg_isready" ]\n      interval: 2s\n      timeout: 5s\n      retries: 10\n    ports:\n      - \'5435:5432\'\n')))}u.isMDXComponent=!0}}]);